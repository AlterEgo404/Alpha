import os
import io
import json
import math
import random
import datetime
import asyncio
import traceback

import discord
from discord.ext import commands
from discord.ui import View, Button

import aiohttp
from PIL import Image, ImageDraw, ImageFont

# ==== DB & internal ====
from pymongo import MongoClient
from keep_alive import keep_alive

# ---- ENV & Secrets ----
DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")  # b·∫Øt bu·ªôc
MONGO_URI = os.getenv("MONGO_URI")          # b·∫Øt bu·ªôc

if not DISCORD_TOKEN:
    raise RuntimeError("Thi·∫øu bi·∫øn m√¥i tr∆∞·ªùng DISCORD_TOKEN")
if not MONGO_URI:
    raise RuntimeError("Thi·∫øu bi·∫øn m√¥i tr∆∞·ªùng MONGO_URI")

# ---- Mongo ----
client = MongoClient(MONGO_URI)

# Load d·ªØ li·ªáu & handler
from data_handler import (
    get_user, update_user, create_user, save_user_full,
    get_jackpot, update_jackpot as dh_update_jackpot, set_jackpot,
    users_col
)

# ---- Discord ----
intents = discord.Intents.all()
bot = commands.Bot(command_prefix='$', intents=intents, help_command=None)

# ---- Constants ----
ALLOWED_CHANNEL_ID = 1347480186198949920
coin = "<:meme_coin:1362951683814199487>"

dice_emojis = {
    0: "<a:dice_roll:1362951541132099584>",
    1: "<:dice_1:1362951590302056849>",
    2: "<:dice_2:1362951604600307792>",
    3: "<:dice_3:1362951621717266463>",
    4: "<:dice_4:1362951636573487227>",
    5: "<:dice_5:1362951651853336727>",
    6: "<:dice_6:1362951664729854152>",
}

# ---- JSON helpers ----
def load_json(file_name, default_data=None):
    if not os.path.exists(file_name):
        default_data = default_data or {}
        with open(file_name, 'w', encoding='utf-8') as f:
            json.dump(default_data, f, ensure_ascii=False, indent=4)
    with open(file_name, 'r', encoding='utf-8') as f:
        return json.load(f)

def save_json(file_name, data):
    with open(file_name, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=4)

shop_data = load_json('shop_data.json')
save_shop_data = lambda data: save_json('shop_data.json', data)

tu_vi = load_json('tu_vi.json')
save_tu_vi = lambda data: save_json('tu_vi.json', data)

gacha_data = load_json('gacha_data.json')
save_gacha_data = lambda data: save_json('gacha_data.json', data)

try:
    with open("backgrounds.json", "r", encoding="utf-8") as f:
        user_backgrounds = json.load(f)
except FileNotFoundError:
    user_backgrounds = {}

# ---- Image/Text helpers ----
def draw_text_with_outline(draw, text, position, font, outline_color="black", fill_color="white"):
    x, y = position
    offsets = [(-2, 0), (2, 0), (0, -2), (0, 2), (-2, -2), (2, -2), (-2, 2), (2, 2)]
    for ox, oy in offsets:
        draw.text((x + ox, y + oy), text, font=font, fill=outline_color)
    draw.text((x, y), text, font=font, fill=fill_color)

def format_currency(amount):
    try:
        return f"{int(amount):,}".replace(",", " ")
    except Exception:
        return str(amount)

def count_items(items):
    counts = {}
    for name in items or {}:
        counts[name] = counts.get(name, 0) + 1
    return counts

# ---- Gacha ----
def roll_gacha_from_pool():
    rarity_list = list(gacha_data["rarity_chance"].keys())
    rarity_weights = list(gacha_data["rarity_chance"].values())
    selected_rarity = random.choices(rarity_list, weights=rarity_weights, k=1)[0]
    item_name = random.choice(gacha_data["gacha_pool"][selected_rarity])
    return {"name": item_name, "rarity": selected_rarity}

def calculate_level_and_progress(smart):
    level = int(math.log2(smart / 5 + 1)) + 1
    needed_smart = 5 * ((2 ** (level - 1)) - 1)
    current_smart = max(0, smart - 5 * ((2 ** (level - 2)) - 1)) if level > 1 else smart
    next_level_needed_smart = 5 * ((2 ** level) - 1)
    progress_percentage = min((smart / next_level_needed_smart) * 100, 100) if next_level_needed_smart > 0 else 0
    return level, round(progress_percentage, 2), next_level_needed_smart

# ---- Permissions & user checks ----
async def check_permission(ctx):
    if ctx.author.id != 1196335145964285984 and ctx.channel.id != ALLOWED_CHANNEL_ID:
        await ctx.reply(f"L·ªánh n√†y ch·ªâ c√≥ th·ªÉ ƒë∆∞·ª£c s·ª≠ d·ª•ng trong <# {ALLOWED_CHANNEL_ID} >")
        return False
    return True

async def check_user_data(ctx, user_id):
    if not get_user(user_id):
        await ctx.reply("C√≥ v·∫ª b·∫°n ch∆∞a ch∆°i l·∫ßn n√†o tr∆∞·ªõc ƒë√¢y vui l√≤ng d√πng `$start` ƒë·ªÉ t·∫°o t√†i kho·∫£n.")
        return False
    return True

# ---- HTTP session (reused) ----
http_session: aiohttp.ClientSession | None = None

async def fetch_image(url: str) -> Image.Image | None:
    """T·∫£i ·∫£nh v√† tr·∫£ v·ªÅ Image RGBA. Tr·∫£ None n·∫øu l·ªói."""
    if not url or not url.startswith(("http://", "https://")):
        return None
    try:
        assert http_session is not None
        async with http_session.get(url) as resp:
            if resp.status != 200:
                print(f"L·ªói t·∫£i ·∫£nh: {resp.status} - {url}")
                return None
            data = await resp.read()
        img = Image.open(io.BytesIO(data))
        return img.convert("RGBA")
    except Exception as e:
        print(f"L·ªói khi t·∫£i ·∫£nh: {e}")
        return None

# ---- Background tasks ----
async def update_company_balances():
    """C·ª© 60s: bi·∫øn ƒë·ªông d∆∞∆°ng/l·ªó nh·∫π v·ªõi balance c√¥ng ty."""
    while True:
        try:
            cursor = users_col.find({"company_balance": {"$gt": 0}}, {"company_balance": 1})
            for doc in cursor:
                uid = doc["_id"]
                balance = doc.get("company_balance", 0)
                modifier = random.choice([-0.01, 0.02])
                new_balance = max(0, int(balance + balance * modifier))
                if new_balance != balance:
                    update_user(uid, {"company_balance": new_balance})
        except Exception:
            traceback.print_exc()
        await asyncio.sleep(60)

async def clean_zero_items():
    """C·ª© 10s: xo√° item c√≥ s·ªë l∆∞·ª£ng <= 0 ƒë·ªÉ g·ªçn DB."""
    while True:
        try:
            cursor = users_col.find({"items": {"$exists": True}})
            for doc in cursor:
                uid = doc["_id"]
                items = doc.get("items", {}) or {}
                new_items = {k: v for k, v in items.items() if isinstance(v, int) and v > 0}
                if new_items != items:
                    update_user(uid, {"items": new_items})
        except Exception:
            traceback.print_exc()
        await asyncio.sleep(10)

# ==== EVENTS ====
@bot.event
async def on_ready():
    global http_session
    print(f'Bot ƒë√£ ƒëƒÉng nh·∫≠p v·ªõi t√™n {bot.user}')
    http_session = aiohttp.ClientSession()

    bot.loop.create_task(update_company_balances())
    bot.loop.create_task(clean_zero_items())

    # Kh·ªüi t·∫°o jackpot n·∫øu ch∆∞a c√≥
    if get_jackpot() is None:
        set_jackpot(1_000_000_000)
        print("ƒê√£ kh·ªüi t·∫°o jackpot m·∫∑c ƒë·ªãnh.")

@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.CommandNotFound):
        await ctx.reply("‚ùå L·ªánh b·∫°n nh·∫≠p kh√¥ng t·ªìn t·∫°i. Vui l√≤ng ki·ªÉm tra l·∫°i :>")
    elif isinstance(error, commands.MissingRequiredArgument):
        await ctx.reply("‚ö†Ô∏è B·∫°n thi·∫øu m·ªôt tham s·ªë c·∫ßn thi·∫øt. Vui l√≤ng ki·ªÉm tra l·∫°i c√∫ ph√°p l·ªánh.")
    elif isinstance(error, commands.BadArgument):
        await ctx.reply("‚ùå ƒê·ªëi s·ªë b·∫°n nh·∫≠p kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.")
    elif isinstance(error, commands.MissingPermissions):
        await ctx.reply("üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    elif isinstance(error, commands.CommandOnCooldown):
        await ctx.reply(f"‚è≥ L·ªánh ƒëang trong th·ªùi gian h·ªìi. Th·ª≠ l·∫°i sau `{round(error.retry_after, 1)} gi√¢y`.")
    elif isinstance(error, commands.CheckFailure):
        await ctx.reply("‚ùóB·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh n√†y ·ªü ƒë√¢y.")
    else:
        # In ƒë·∫ßy ƒë·ªß stacktrace cho d·ªÖ debug
        traceback.print_exc()
        await ctx.reply("‚ö†Ô∏è ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën. Vui l√≤ng th·ª≠ l·∫°i sau!")

@bot.event
async def on_close():
    # ƒë√≥ng session HTTP n·∫øu c√≥
    global http_session
    try:
        if http_session and not http_session.closed:
            await http_session.close()
    finally:
        http_session = None

# ==== COMMANDS ==== 
# (Ph·∫ßn d∆∞·ªõi GI·ªÆ NGUY√äN ƒëa s·ªë logic c·ªßa b·∫°n; ch·ªâ s·ª≠a c√°c ƒëi·ªÉm l·ªói/b·∫£o m·∫≠t)

@bot.command(name="start", help='`$start`\n> Kh·ªüi t·∫°o t√†i kho·∫£n')
async def start(ctx):
    user_id = str(ctx.author.id)
    member = ctx.author

    if get_user(user_id):
        await ctx.reply(f"B·∫°n ƒë√£ c√≥ t√†i kho·∫£n r·ªìi, {ctx.author.mention} ∆°i! Kh√¥ng c·∫ßn t·∫°o l·∫°i n·ªØa.")
        return

    user_data = {"points": 10000, "items": {}, "smart": 100}
    create_user(user_id, user_data)

    role_id = 1316985467853606983
    role = ctx.guild.get_role(role_id)
    if role:
        if role not in member.roles:
            await member.add_roles(role)
    else:
        await ctx.reply("Kh√¥ng th·ªÉ t√¨m th·∫•y vai tr√≤ c·∫ßn thi·∫øt trong server.")

    await ctx.reply(f"T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng, {ctx.author.mention}!")

@bot.command(name="info", help='`$info`\n> xem th√¥ng tin c·ªßa Bot')
async def info(ctx):
    if not await check_permission(ctx): return
    embed = discord.Embed(title="üìä Th√¥ng tin Bot", color=discord.Color.red())
    embed.add_field(name="üë©‚Äçüíª Nh√† ph√°t tri·ªÉn", value="```ansi\n[2;31mAlpha[0m```", inline=True)
    embed.add_field(name="Phi√™n b·∫£n Bot", value="```ansi\n[2;34m2.0.0[0m```")
    embed.set_thumbnail(url="https://cdn.discordapp.com/attachments/1322746396142604378/1322746745440043143/2.png")
    await ctx.reply(embed=embed)

@bot.command(name="jar", help='`$jar`\n> xem h≈© jackpot')
async def jp(ctx):
    if not await check_permission(ctx): return
    jackpot_amount = format_currency(get_jackpot() or 0)
    await ctx.reply(f"üí∞ **Jackpot hi·ªán t·∫°i:** {jackpot_amount} {coin}")

@bot.command(name="mk", help='`$mk`\n> xem c·ª≠a h√†ng')
async def shop(ctx):
    if not await check_permission(ctx): return
    embed = discord.Embed(
        title="üè¨ **C·ª≠a h√†ng**",
        description="Mua: `$buy <id> <s·ªë l∆∞·ª£ng>` ‚Ä¢ B√°n: `$sell <id> <s·ªë l∆∞·ª£ng>`",
        color=discord.Color.red()
    )
    for item_id, item in shop_data.items():
        name = item.get("name", "Kh√¥ng t√™n")
        price = item.get("price", 0)
        icon = item.get("icon", "")
        embed.add_field(
            name=f"`{item_id}` {icon} {name}",
            value=f"`{format_currency(price)}` {coin}",
            inline=True
        )
    await ctx.reply(embed=embed)

@bot.command(name="buy")
async def buy(ctx, item_id: str, quantity: int):
    if not await check_permission(ctx): return
    user_id = str(ctx.author.id)

    if not await check_user_data(ctx, user_id): return
    if item_id not in shop_data:
        await ctx.reply("Kh√¥ng t√¨m th·∫•y m·∫∑t h√†ng trong c·ª≠a h√†ng.")
        return
    if quantity <= 0:
        await ctx.reply("S·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n kh√¥ng.")
        return

    item_data = shop_data[item_id]
    item_name = item_data['name']
    user = get_user(user_id)
    if not user:
        await ctx.reply("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ng∆∞·ªùi d√πng.")
        return

    user_items = user.get('items', {}) or {}
    total_price = int(item_data['price']) * int(quantity)

    if total_price > user.get('points', 0):
        await ctx.reply("B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ mua m√≥n n√†y.")
        return

    if item_id == "01" and "company_balance" not in user:
        user["company_balance"] = 0

    user['points'] = user.get('points', 0) - total_price
    user_items[item_name] = int(user_items.get(item_name, 0)) + int(quantity)
    user['items'] = user_items
    update_user(user_id, user)

    await ctx.reply(f"B·∫°n ƒë√£ mua {quantity} {item_name}.")

@bot.command(name="sell")
async def sell(ctx, item_id: str, quantity: int):
    if not await check_permission(ctx): return
    user_id = str(ctx.author.id)

    if not await check_user_data(ctx, user_id): return
    if item_id not in shop_data:
        await ctx.reply("Kh√¥ng th·∫•y m·∫∑t h√†ng n√†y trong c·ª≠a h√†ng.")
        return
    if quantity <= 0:
        await ctx.reply("S·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n kh√¥ng.")
        return

    item_data = shop_data[item_id]
    item_name = item_data['name']
    selling_price = round(int(item_data['price']) * int(quantity) * 0.9)

    user = get_user(user_id)
    if not user:
        await ctx.reply("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ng∆∞·ªùi d√πng.")
        return

    user_items = user.get('items', {}) or {}
    current_quantity = int(user_items.get(item_name, 0))

    if current_quantity < quantity:
        await ctx.reply("B·∫°n kh√¥ng c√≥ ƒë·ªß m·∫∑t h√†ng n√†y ƒë·ªÉ b√°n.")
        return

    user_items[item_name] = current_quantity - quantity

    if item_id == "01" and user_items.get(":office: C√¥ng ty", 0) == 0:
        user.pop("company_balance", None)

    user['points'] = int(user.get('points', 0)) + selling_price
    user['items'] = user_items
    update_user(user_id, user)

    await ctx.reply(f"B·∫°n ƒë√£ b√°n {quantity} {item_name} v√† nh·∫≠n {format_currency(selling_price)} {coin}.")

@bot.command(name="ttsp", help="`$ttsp <id s·∫£n ph·∫©m>`\n> Hi·ªÉn th·ªã th√¥ng tin s·∫£n ph·∫©m")
async def ttsp(ctx, item_id):
    item_data = shop_data.get(item_id)
    if not item_data:
        await ctx.reply("Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m v·ªõi ID n√†y.")
        return
    embed = discord.Embed(
        title=f"Th√¥ng tin s·∫£n ph·∫©m:\n{item_data.get('name','(Kh√¥ng t√™n)')}",
        color=discord.Color.red()
    )
    embed.add_field(name="M√¥ t·∫£", value=item_data.get('description','(kh√¥ng c√≥)'), inline=False)
    embed.add_field(name="Gi√° mua", value=f'`{format_currency(item_data.get("price",0))}` {coin}', inline=True)
    embed.add_field(name="Gi√° b√°n", value=f'`{format_currency(round(item_data.get("price",0) * 0.9))}` {coin}', inline=True)
    await ctx.reply(embed=embed)

@bot.command(name="setb")
async def set_background(ctx, member: discord.Member, background_url: str):
    if ctx.author.id != 1196335145964285984:
        await ctx.reply("Ch·ªâ ng∆∞·ªùi d√πng ƒë∆∞·ª£c ph√©p m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    if not background_url.startswith(("http://", "https://")):
        await ctx.reply("URL kh√¥ng h·ª£p l·ªá. Vui l√≤ng cung c·∫•p URL h·ª£p l·ªá.")
        return

    user_id = str(member.id)
    user_backgrounds[user_id] = background_url
    with open("backgrounds.json", "w", encoding="utf-8") as f:
        json.dump(user_backgrounds, f, ensure_ascii=False, indent=4)
    await ctx.reply(f"ƒê√£ thay ƒë·ªïi n·ªÅn c·ªßa {member.display_name} th√†nh: {background_url}")

@bot.command(name="cccd", help='`$cccd`\n> m·ªü cƒÉn c∆∞·ªõc c√¥ng d√¢n')
async def cccd(ctx, member: discord.Member = None, size: int = 128):
    if not await check_permission(ctx): return
    member = member or ctx.author
    user_id = str(member.id)

    if not await check_user_data(ctx, user_id): return

    background_url = user_backgrounds.get(
        user_id,
        "https://hinhanhonline.com/Hinhanh/images07/AnhAL/hinh-nen-may-tinh-dep-doc-dao-nhat-19.jpg"
    )

    data = get_user(user_id)
    smart = int(data.get("smart", 0))
    user_name = member.name
    avatar_url = member.display_avatar.with_size(size).url

    level, progress_percentage, next_level_needed_smart = calculate_level_and_progress(smart)

    # C·∫≠p nh·∫≠t vai tr√≤ theo tu_vi
    async def update_roles(ctx, member, level):
        for role_info in tu_vi.values():
            role = ctx.guild.get_role(role_info.get("id"))
            if role and role in member.roles:
                await member.remove_roles(role)

        role_name = "None"
        role_id = None
        for name, info in sorted(tu_vi.items(), key=lambda x: x[1]["level_min"], reverse=True):
            if level >= info["level_min"]:
                role_name = name
                role_id = info["id"]
                break

        if role_id:
            role = ctx.guild.get_role(role_id)
            if role and role not in member.roles:
                await member.add_roles(role)
        return role_name

    role_name = await update_roles(ctx, member, level)

    # t·∫£i ·∫£nh
    avatar_image = await fetch_image(avatar_url)
    if avatar_image is None:
        await ctx.reply("L·ªói t·∫£i ·∫£nh avatar. Vui l√≤ng th·ª≠ l·∫°i sau.")
        return
    avatar_image = avatar_image.resize((120, 120))

    galaxy_background = await fetch_image(background_url)
    if galaxy_background is None:
        await ctx.reply("L·ªói t·∫£i ·∫£nh n·ªÅn. Vui l√≤ng th·ª≠ l·∫°i sau.")
        return
    galaxy_background = galaxy_background.resize((400, 225))

    try:
        server_image = Image.open("1.png").convert("RGBA")
    except Exception:
        await ctx.reply("L·ªói t·∫£i ·∫£nh server (1.png).")
        return
    server_image = server_image.resize((80, 80))

    # gh√©p
    canvas = galaxy_background.copy()
    canvas.paste(server_image, (10, 10), mask=server_image)
    canvas.paste(avatar_image, (20, 85), mask=avatar_image)

    # font
    font_path = "Roboto-Black.ttf"
    try:
        font_small = ImageFont.truetype(font_path, 12)
        font_large = ImageFont.truetype(font_path, 13)
    except IOError:
        font_large = font_small = ImageFont.load_default()

    draw = ImageDraw.Draw(canvas)
    draw_text_with_outline(
        draw,
        f"T√™n: {user_name}\nID: {user_id}\nH·ªçc v·∫•n: {format_currency(smart)}\nlv: {format_currency(level)}\nTr√¨nh ƒë·ªô: {role_name}",
        (160, 95),
        font_large
    )
    draw_text_with_outline(
        draw,
        "C·ªòNG H√íA X√É H·ªòI CH·ª¶ NGHƒ®A MEME\n          ƒê·ªôc l·∫≠p - T·ª± do - H·∫°nh ph√∫c\n\n                 CƒÇN C∆Ø·ªöC C∆Ø D√ÇN",
        (100, 20),
        font_large
    )

    # progress bar
    filled_length = int(progress_percentage * 2)  # 0..200
    bar_position = (160, 185, 360, 205)
    draw.rectangle(bar_position, outline="black", width=3)
    draw.rectangle((163, 188, 163 + max(0, filled_length - 6), 202), fill="#1E90FF")
    draw_text_with_outline(draw, f"{smart}/{next_level_needed_smart}", (165, 188), font_small)

    with io.BytesIO() as bio:
        canvas.save(bio, "PNG")
        bio.seek(0)
        await ctx.reply(file=discord.File(fp=bio, filename="cccd.png"))

@bot.command(name="bag", help='`$bag`\n> m·ªü t√∫i')
async def bag(ctx, member: discord.Member = None):
    if not await check_permission(ctx):
        return

    member = member or ctx.author
    user_id = str(member.id)

    if not await check_user_data(ctx, user_id):
        return

    # L·∫•y d·ªØ li·ªáu ng∆∞·ªùi d√πng t·ª´ MongoDB
    data = get_user(user_id)
    points = format_currency(data.get('points', 0))
    items = data.get('items', {})
    company_balance = data.get("company_balance")

    # ƒê·ªãnh d·∫°ng danh s√°ch item
    if not items:
        item_list = "Tr·ªëng."
    else:
        item_list = ""
        for item_name, quantity in items.items():
            item_list += f"{item_name}: {quantity}\n"

    company_text = f"**C√¥ng ty**: {format_currency(company_balance)} {coin}." if company_balance is not None else ""

    # T·∫°o embed tr·∫£ v·ªÅ
    embed = discord.Embed(
        title=f"**:luggage: T√∫i**\n{member}",
        description=(f"**T√†i kho·∫£n**: {points} {coin}.\n"
                     f"**Kho ƒë·ªì**:\n{item_list}"
                     f"{company_text}"),
        color=discord.Color.red()
    )

    await ctx.reply(embed=embed)

@bot.command(name="ou", help='`$ou <ƒëi·ªÉm> <t/x>`\n> ch∆°i t√†i x·ªâu')
async def ou(ctx, bet: str, choice: str):
    if not await check_permission(ctx):
        return

    user_id = str(ctx.author.id)

    data = get_user(user_id)
    if not data:
        await ctx.reply("C√≥ v·∫ª b·∫°n ch∆∞a ch∆°i l·∫ßn n√†o tr∆∞·ªõc ƒë√¢y vui l√≤ng d√πng `$start` ƒë·ªÉ t·∫°o t√†i kho·∫£n.")
        return

    if bet.lower() == 'all':
        bet = data.get('points', 0)
    else:
        try:
            bet = int(bet)
        except ValueError:
            await ctx.reply(f"S·ªë {coin} c∆∞·ª£c kh√¥ng h·ª£p l·ªá.")
            return

    if bet <= 0 or bet > data.get('points', 0):
        await ctx.reply("B·∫°n l√†m ƒë√©o g√¨ c√≥ ti·ªÅn m√† c∆∞·ª£c :rofl:")
        return

    choice = choice.lower()
    if choice not in ["t", "x"]:
        await ctx.reply("B·∫°n ph·∫£i ch·ªçn 't' (T√†i) ho·∫∑c 'x' (X·ªâu).")
        return

    if user_id == "1361702060071850024":
        dice1, dice2, dice3 = random.randint(1, 3), random.randint(1, 3), random.randint(1, 3)
    else:
        dice1, dice2, dice3 = random.randint(1, 6), random.randint(1, 6), random.randint(1, 6)
    total = dice1 + dice2 + dice3

    # T√≠nh k·∫øt qu·∫£
    win = (3 <= total <= 10 and choice == "x") or (11 <= total <= 18 and choice == "t")
    if win:
        data['points'] += bet
    else:
        data['points'] -= bet
        dh_update_jackpot(bet)  # C·∫≠p nh·∫≠t jackpot n·∫øu thua

    update_user(user_id, data)

    # Hi·ªÉn th·ªã x√∫c x·∫Øc
    dice1_emoji = dice_emojis[dice1]
    dice2_emoji = dice_emojis[dice2]
    dice3_emoji = dice_emojis[dice3]
    dice_roll = dice_emojis[0]

    if choice == 'x':
        rolling_message = await ctx.reply(f"`   ` {dice_roll} `   `\n`  `{dice_roll} {dice_roll}`$$`")
    else:
        rolling_message = await ctx.reply(f"`   ` {dice_roll} `   `\n`$$`{dice_roll} {dice_roll}`  `")
    await asyncio.sleep(1)

    if 3 <= total <= 10:
        if choice == "x":
            await rolling_message.edit(content=f"`   ` {dice1_emoji} `X·ªâu`\n`  `{dice2_emoji} {dice3_emoji}`$$`")
        else:
            await rolling_message.edit(content=f"`   ` {dice1_emoji} `X·ªâu`\n`$$`{dice2_emoji} {dice3_emoji}`  `\nHehe, {ctx.author.mention} ngu th√¨ ch·∫øt ch·ª© sao :rofl:")
    else:
        if choice == "x":
            await rolling_message.edit(content=f"`T√†i` {dice1_emoji} `   `\n`  `{dice2_emoji} {dice3_emoji}`$$`\nHehe, {ctx.author.mention} ngu th√¨ ch·∫øt ch·ª© sao :rofl:")
        else:
            await rolling_message.edit(content=f"`T√†i` {dice1_emoji} `   `\n`$$`{dice2_emoji} {dice3_emoji}`  `")

@bot.command(name="daily", help='`$daily`\n> nh·∫≠n qu√† h·∫±ng ng√†y')
async def daily(ctx):
    if not await check_permission(ctx):
        return

    user_id = str(ctx.author.id)

    data = get_user(user_id)
    if not data:
        await ctx.reply("C√≥ v·∫ª b·∫°n ch∆∞a ch∆°i l·∫ßn n√†o tr∆∞·ªõc ƒë√¢y vui l√≤ng d√πng `$start` ƒë·ªÉ t·∫°o t√†i kho·∫£n.")
        return

    last_daily = data.get('last_daily')
    now = datetime.datetime.now()

    if last_daily is not None:
        last_daily_date = datetime.datetime.strptime(last_daily, "%Y-%m-%d")

        if last_daily_date.date() == now.date():
            next_daily = last_daily_date + datetime.timedelta(days=1)
            time_remaining = next_daily - now
            hours, remainder = divmod(time_remaining.seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            await ctx.reply(f"B·∫°n ƒë√£ nh·∫≠n qu√† h·∫±ng ng√†y r·ªìi. Vui l√≤ng th·ª≠ l·∫°i sau: {hours} gi·ªù {minutes} ph√∫t {seconds} gi√¢y.")
            return

        elif (now - last_daily_date).days == 1:
            data['streak'] = data.get('streak', 0) + 1
        else:
            data['streak'] = 1
    else:
        data['streak'] = 1

    base_reward = 5000
    streak_bonus = data['streak'] * 100
    total_reward = base_reward + streak_bonus

    data['points'] = data.get('points', 0) + total_reward
    data['last_daily'] = now.strftime("%Y-%m-%d")

    update_user(user_id, data)

    await ctx.reply(
        f"B·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c {format_currency(total_reward)} {coin}!"
        f" (Th∆∞·ªüng streak: {streak_bonus} {coin}, chu·ªói ng√†y: {data['streak']} ng√†y)"
    )

@bot.command(name="prog", help='`$prog`\n> ƒÉn xin')
async def prog(ctx):
    if not await check_permission(ctx):
        return

    user_id = str(ctx.author.id)
    data = get_user(user_id)

    if not data:
        await ctx.reply("C√≥ v·∫ª b·∫°n ch∆∞a ch∆°i l·∫ßn n√†o tr∆∞·ªõc ƒë√¢y vui l√≤ng d√πng `$start` ƒë·ªÉ t·∫°o t√†i kho·∫£n.")
        return

    last_beg = data.get('last_beg')
    now = datetime.datetime.now()

    if last_beg is not None:
        cooldown_time = 3 * 60  # 3 ph√∫t
        time_elapsed = (now - datetime.datetime.strptime(last_beg, "%Y-%m-%d %H:%M:%S")).total_seconds()

        if time_elapsed < cooldown_time:
            minutes, seconds = divmod(int(cooldown_time - time_elapsed), 60)
            await ctx.reply(f"B·∫°n ƒë√£ ƒÉn xin r·ªìi, vui l√≤ng th·ª≠ l·∫°i sau {minutes} ph√∫t {seconds} gi√¢y.")
            return

    if data.get('points', 0) < 100_000:
        beg_amount = random.randint(0, 5000)
        data['points'] = data.get('points', 0) + beg_amount
    else:
        await ctx.reply('gi√†u m√† c√≤n ƒëi ƒÉn xin ƒë√©o th·∫•y nh·ª•c √†')
        return

    data['last_beg'] = now.strftime("%Y-%m-%d %H:%M:%S")

    update_user(user_id, data)

    await ctx.reply(f"B·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c {format_currency(beg_amount)} {coin} t·ª´ vi·ªác ƒÉn xin!")

@bot.command(name="dn", help='`$dn <ƒëi·ªÉm> <ng∆∞·ªùi ch∆°i>`\n> donate ƒëi·ªÉm cho ng∆∞·ªùi kh√°c')
async def give(ctx, amount: int, member: discord.Member):
    if not await check_permission(ctx):
        return

    giver_id = str(ctx.author.id)
    receiver_id = str(member.id)

    giver_data = get_user(giver_id)
    receiver_data = get_user(receiver_id)

    if not giver_data:
        await ctx.reply("C√≥ v·∫ª b·∫°n ch∆∞a ch∆°i l·∫ßn n√†o tr∆∞·ªõc ƒë√¢y vui l√≤ng d√πng `$start` ƒë·ªÉ t·∫°o t√†i kho·∫£n.")
        return

    if not receiver_data:
        await ctx.reply("C√≥ v·∫ª ƒë·ªëi t∆∞·ª£ng ch∆∞a ch∆°i l·∫ßn n√†o tr∆∞·ªõc ƒë√¢y vui l√≤ng d√πng `$start` ƒë·ªÉ t·∫°o t√†i kho·∫£n.")
        return

    if amount <= 0:
        await ctx.reply(f"S·ªë {coin} ph·∫£i l·ªõn h∆°n 0!")
        return

    if amount > giver_data.get('points', 0):
        await ctx.reply(f"B·∫°n kh√¥ng ƒë·ªß {coin} ƒë·ªÉ t·∫∑ng!")
        return

    # Tr·ª´ ƒëi·ªÉm ng∆∞·ªùi g·ª≠i, c·ªông ƒëi·ªÉm ng∆∞·ªùi nh·∫≠n
    giver_data['points'] -= amount
    receiver_data['points'] += amount

    # L∆∞u d·ªØ li·ªáu
    update_user(giver_id, giver_data)
    update_user(receiver_id, receiver_data)

    await ctx.reply(f"B·∫°n ƒë√£ t·∫∑ng {format_currency(amount)} {coin} cho {member.mention}!")

@bot.command(name="?", aliases=["help"], help="Hi·ªÉn th·ªã danh s√°ch l·ªánh ho·∫∑c th√¥ng tin chi ti·∫øt v·ªÅ m·ªôt l·ªánh.")
async def help(ctx, command=None):
    """Provides detailed help for commands or a general list of commands."""

    if command is None:
        embed = discord.Embed(
            title="Danh s√°ch l·ªánh",
            description=(
                f"L·ªánh t√†i kho·∫£n:\n> `$start`, `$lb`, `$dn`, `$cccd`, `$bag`\n"
                f"L·ªánh mua b√°n:\n> `$mk`, `$ttsp`, `$buy`, `$sell`\n"
                f"L·ªánh ki·∫øm ti·ªÅn:\n> `$daily`, `$prog`, `$hunt`\n"
                f"L·ªánh t·ªá n·∫°n:\n> `$ou`, `$thief`, `$othief`, `$slots`\n"
                f"L·ªánh h·ªçc v·∫•n:\n> `$op`, `$study`"
            ),
            color=discord.Color.red()
        )
        
        await ctx.reply(embed=embed)
    else:
        cmd = bot.get_command(command)
        if cmd:
            embed = discord.Embed(title=f"L·ªánh: `{cmd.name}`", description=cmd.help, color=discord.Color.red())
            await ctx.send(embed=embed)
        else:
            await ctx.send("L·ªánh kh√¥ng t·ªìn t·∫°i.")

@bot.command(name="thief", help='`$thief <ng∆∞·ªùi ch∆°i> [c√¥ng c·ª•]`\n> tr·ªôm 50% ƒëi·ªÉm c·ªßa ng∆∞·ªùi kh√°c')
async def rob(ctx, member: discord.Member, tool: str = None):
    if not await check_permission(ctx):
        return

    robber_id = str(ctx.author.id)
    victim_id = str(member.id)
    status = member.status

    robber_data = get_user(robber_id)
    victim_data = get_user(victim_id)

    if not robber_data:
        await ctx.reply("B·∫°n ch∆∞a c√≥ t√†i kho·∫£n. D√πng `$start` ƒë·ªÉ t·∫°o.")
        return
    if not victim_data:
        await ctx.reply("N·∫°n nh√¢n ch∆∞a c√≥ t√†i kho·∫£n.")
        return
    if victim_id == '1243079760062709854':
        await ctx.reply("ƒê·ªãnh l√†m g√¨ v·ªõi Admin Bot ƒë·∫•y?")
        return
    if status == discord.Status.online:
        await ctx.reply("N√≥ ƒëang online ƒë·∫•y, c·∫©n th·∫≠n kh√¥ng n√≥ ƒë·∫•m!")
        return

    now = datetime.datetime.now()
    last_rob = robber_data.get("last_rob")
    if last_rob:
        elapsed = (now - datetime.datetime.strptime(last_rob, "%Y-%m-%d %H:%M:%S")).total_seconds()
        if elapsed < 3600:
            skip = robber_data.get("items", {}).get(":fast_forward: Skip", 0)
            if skip > 0:
                update_user(robber_id, {"$inc": {"items.:fast_forward: Skip": -1}})
                await ctx.reply("B·∫°n ƒë√£ d√πng :fast_forward: Skip ƒë·ªÉ b·ªè qua th·ªùi gian ch·ªù!")
            else:
                remaining = 3600 - int(elapsed)
                h, m = divmod(remaining, 60*60)
                m, s = divmod(m, 60)
                await ctx.reply(f"B·∫°n ph·∫£i ch·ªù {h} gi·ªù {m} ph√∫t {s} gi√¢y n·ªØa.")
                return

    items_r = robber_data.get("items", {})
    items_v = victim_data.get("items", {})
    has_lock = items_v.get(":lock: ·ªî kh√≥a", 0) > 0
    pet_guard = items_v.get(":dog: Pet b·∫£o v·ªá", 0) > 0
    pet_thief = items_r.get(":cat: Pet tr·ªôm", 0) > 0

    if has_lock:
        tools = {
            "b": { "emoji": ":bomb: Bom", "chance": 0.75 },
            "w": { "emoji": ":wrench: K√¨m", "chance": 0.5 },
            "c": { "emoji": "<:cleaner:1347560866291257385> m√°y h√∫t b·ª•i", "chance": 0.85 }
        }

        chosen_tool = tool.lower() if tool else None
        if chosen_tool in tools:
            tool_data = tools[chosen_tool]
            emoji = tool_data["emoji"]
            if items_r.get(emoji, 0) <= 0:
                await ctx.reply("B·∫°n kh√¥ng c√≥ c√¥ng c·ª• ƒë√≥.")
                return
            chance = tool_data["chance"]
            if pet_guard:
                chance -= 0.1
            if pet_thief:
                chance += 0.1
            success = random.random() < chance
            if success:
                update_user(victim_id, {"$inc": {f"items.:lock: ·ªî kh√≥a": -1}})
                update_user(robber_id, {"$inc": {f"items.{emoji}": -1}})
                if chosen_tool == "c":
                    if items_v:
                        random_item = random.choice(list(items_v.keys()))
                        update_user(victim_id, {"$inc": {f"items.{random_item}": -2000}})
                        await ctx.reply(f"D√πng {emoji} ph√° kh√≥a v√† h√∫t 2000 {random_item} c·ªßa {member.mention}!")
                    else:
                        await ctx.reply("D√πng m√°y h√∫t b·ª•i ph√° kho√°, nh∆∞ng h·ªç kh√¥ng c√≥ g√¨ ƒë·ªÉ h√∫t.")
                else:
                    await ctx.reply(f"B·∫°n ƒë√£ d√πng {emoji} v√† ph√° v·ª° ·ªî kh√≥a c·ªßa {member.mention}!")
            else:
                await ctx.reply("Ph√° kho√° th·∫•t b·∫°i!")
                return
        else:
            await ctx.reply("Ch·ªçn `b`, `w`, ho·∫∑c `c` l√†m c√¥ng c·ª•.")
            return

    victim_points = victim_data.get("points", 0)
    if victim_points <= 0:
        await ctx.reply(f"{member.name} kh√¥ng c√≥ {coin} ƒë·ªÉ c∆∞·ªõp.")
        return

    stolen = round(victim_points * 0.5)
    update_user(victim_id, {"$inc": {"points": -stolen}})
    update_user(robber_id, {
        "$inc": {"points": stolen},
        "$set": {"last_rob": now.strftime("%Y-%m-%d %H:%M:%S")}
    })
    await ctx.reply(f"B·∫°n ƒë√£ c∆∞·ªõp {format_currency(stolen)} {coin} t·ª´ {member.name}!")

@bot.command(name="hunt", help='`$hunt <weapon>`\n> ƒëi sƒÉn ki·∫øm ti·ªÅn')
async def hunt(ctx, weapon: str):
    if not await check_permission(ctx):
        return

    user_id = str(ctx.author.id)
    data = get_user(user_id)
    if not data:
        await ctx.reply("B·∫°n ch∆∞a c√≥ t√†i kho·∫£n. D√πng `$start` ƒë·ªÉ t·∫°o.")
        return

    weapons = {
        "g": { "emoji": ":gun: S√∫ng sƒÉn", "ammo": 1, "range": (0, 50000) },
        "r": { "emoji": "<:RPG:1325750069189677087> RPG", "ammo": 10, "range": (-2000000, 5000000) },
        "a": { "emoji": "<:Awm:1325747265045794857> Awm", "ammo": 1, "range": (5000, 1000000) },
        "c": { "emoji": "<:cleaner:1347560866291257385> m√°y h√∫t b·ª•i", "ammo": 0, "range": (3000000, 10000000) }
    }

    if weapon not in weapons:
        await ctx.reply("V≈© kh√≠ kh√¥ng h·ª£p l·ªá!")
        return

    now = datetime.datetime.now()
    last_hunt = data.get("last_hunt")
    if last_hunt:
        elapsed = (now - datetime.datetime.strptime(last_hunt, "%Y-%m-%d %H:%M:%S")).total_seconds()
        if elapsed < 300:
            remaining = int(300 - elapsed)
            m, s = divmod(remaining, 60)
            await ctx.reply(f"Ch·ªù {m} ph√∫t {s} gi√¢y tr∆∞·ªõc khi sƒÉn ti·∫øp!")
            return

    weapon_info = weapons[weapon]
    items = data.get("items", {})
    weapon_count = items.get(weapon_info["emoji"], 0)
    bullet_count = items.get(":bullettrain_side: Vi√™n ƒë·∫°n", 0)

    if weapon_count < 1:
        await ctx.reply(f"B·∫°n c·∫ßn {weapon_info['emoji']} ƒë·ªÉ ƒëi sƒÉn!")
        return
    if bullet_count < weapon_info["ammo"]:
        await ctx.reply(f"B·∫°n c·∫ßn {weapon_info['ammo']} vi√™n ƒë·∫°n ƒë·ªÉ ƒëi sƒÉn!")
        return

    update = {
        "$inc": {
            "points": random.randint(*weapon_info["range"]),
            "items.:bullettrain_side: Vi√™n ƒë·∫°n": -weapon_info["ammo"]
        },
        "$set": { "last_hunt": now.strftime("%Y-%m-%d %H:%M:%S") }
    }

    if weapon == "c":
        update["$inc"].pop("items.:bullettrain_side: Vi√™n ƒë·∫°n", None)
        update["$unset"] = {f"items.{weapon_info['emoji']}": ""}

    update_user(user_id, update)
    reward = update["$inc"].get("points", 0)
    await ctx.reply(f"B·∫°n ƒë√£ sƒÉn ƒë∆∞·ª£c {format_currency(reward)} {coin}!")

@bot.command(name="in", help='`$in <s·ªë ƒëi·ªÉm>`\n> b∆°m ti·ªÅn v√†o c√¥ng ty')
async def invest(ctx, amount: int):
    if not await check_permission(ctx):
        return

    user_id = str(ctx.author.id)
    user = get_user(user_id)

    if user is None:
        await ctx.reply("Ng∆∞·ªùi ch∆°i kh√¥ng t·ªìn t·∫°i.")
        return

    if ':office: C√¥ng ty' not in user.get('items', {}):
        await ctx.reply(f"{ctx.author.mention} B·∫°n l√†m ƒë√©o g√¨ c√≥ :office: C√¥ng ty m√† ƒë·∫ßu t∆∞ :rofl:")
        return

    if amount <= 0:
        await ctx.reply("S·ªë ƒëi·ªÉm ph·∫£i l·ªõn h∆°n 0.")
        return

    if user['points'] < amount:
        await ctx.reply(f"B·∫°n kh√¥ng c√≥ ƒë·ªß {coin} ƒë·ªÉ ƒë·∫ßu t∆∞.")
        return

    # C·∫≠p nh·∫≠t
    user['points'] -= amount
    user['company_balance'] = user.get('company_balance', 0) + amount
    update_user(user_id, user)

    await ctx.reply(f"B·∫°n ƒë√£ ƒë·∫ßu t∆∞ {format_currency(amount)} {coin} v√†o c√¥ng ty.")

@bot.command(name="wi", help='`$wi <s·ªë ƒëi·ªÉm>`\n> r√∫t ti·ªÅn ra')
async def withdraw(ctx, amount: int):
    if not await check_permission(ctx):
        return

    user_id = str(ctx.author.id)
    user = get_user(user_id)

    if user is None:
        await ctx.reply("Ng∆∞·ªùi ch∆°i kh√¥ng t·ªìn t·∫°i.")
        return

    if amount <= 0:
        await ctx.reply("S·ªë ƒëi·ªÉm ph·∫£i l·ªõn h∆°n 0.")
        return

    if user.get('company_balance', 0) < amount:
        await ctx.reply(f"C√¥ng ty c·ªßa b·∫°n kh√¥ng c√≥ ƒë·ªß {coin} ƒë·ªÉ r√∫t.")
        return

    # C·∫≠p nh·∫≠t
    user['company_balance'] -= amount
    user['points'] += amount
    update_user(user_id, user)

    await ctx.reply(f"B·∫°n ƒë√£ r√∫t {format_currency(amount)} {coin} t·ª´ c√¥ng ty.")

@bot.command(name="othief", help='`$othief <ng∆∞·ªùi ch∆°i>`\n> r√∫t ti·ªÅn t·ª´ c√¥ng ty th·∫±ng b·∫°n')
async def orob(ctx, member: discord.Member):
    if not await check_permission(ctx):
        return

    orobber_id = str(ctx.author.id)
    victim_id = str(member.id)
    status = member.status

    orobber = get_user(orobber_id)
    victim = get_user(victim_id)

    if orobber is None:
        await ctx.reply("C√≥ v·∫ª b·∫°n ch∆∞a ch∆°i l·∫ßn n√†o tr∆∞·ªõc ƒë√¢y vui l√≤ng d√πng `$start` ƒë·ªÉ t·∫°o t√†i kho·∫£n.")
        return

    if victim is None:
        await ctx.reply("N·∫°n nh√¢n ko c√≥ trong d·ªØ li·ªáu c·ªßa tr√≤ ch∆°i.")
        return

    now = datetime.datetime.now()
    last_rob = orobber.get('last_rob')
    if last_rob:
        time_elapsed = (now - datetime.datetime.strptime(last_rob, "%Y-%m-%d %H:%M:%S")).total_seconds()
        cooldown_time = 60 * 60
        if time_elapsed < cooldown_time:
            if orobber['items'].get(':fast_forward: Skip', 0) > 0:
                orobber['items'][':fast_forward: Skip'] -= 1
                await ctx.reply(f"B·∫°n ƒë√£ s·ª≠ d·ª•ng :fast_forward: Skip ƒë·ªÉ b·ªè qua th·ªùi gian ch·ªù!")
            else:
                minutes, seconds = divmod(int(cooldown_time - time_elapsed), 60)
                hours, minutes = divmod(minutes, 60)
                await ctx.reply(f"B·∫°n ph·∫£i ch·ªù {hours} gi·ªù {minutes} ph√∫t {seconds} gi√¢y tr∆∞·ªõc khi c∆∞·ªõp l·∫°i.")
                return

    if status == discord.Status.online:
        await ctx.reply('N√≥ ƒëang on ƒë·∫øy, c·∫©n th·∫≠n ko n√≥ ƒë·∫•m')
        return
        
    if victim_id == "1243079760062709854":
        await ctx.reply('ƒê·ªãnh l√†m g√¨ v·ªõi c√¥ng ty c·ªßa Admin Bot ƒë·∫øy, m√†y c·∫©n th·∫≠n')
        return

    if orobber['items'].get(':credit_card: th·∫ª c√¥ng ty gi·∫£', 0) > 0:
        orobber['items'][':credit_card: th·∫ª c√¥ng ty gi·∫£'] -= 1
        if random.random() < 0.25:
            await ctx.reply(f"B·∫°n ƒë√£ s·ª≠ d·ª•ng Th·∫ª gi·∫£ ƒë·ªÉ r√∫t {coin} c·ªßa {member.name} v√† ƒë√£ th√†nh c√¥ng!")

            victim_balance = victim.get('company_balance', 0)
            if victim_balance <= 0:
                await ctx.reply(f"{member.name} kh√¥ng c√≥ {coin} ƒë·ªÉ c∆∞·ªõp!")
                return

            stolen_points = round(victim_balance * 0.5)

            victim['company_balance'] -= stolen_points
            orobber['points'] += stolen_points
            orobber['last_rob'] = now.strftime("%Y-%m-%d %H:%M:%S")

            update_user(orobber_id, orobber)
            update_user(victim_id, victim)

            await ctx.reply(f"B·∫°n ƒë√£ r√∫t ƒë∆∞·ª£c {format_currency(stolen_points)} {coin} t·ª´ {member.name}!")
        else:
            update_user(orobber_id, orobber)
            await ctx.reply(f"B·∫°n ƒë√£ s·ª≠ d·ª•ng Th·∫ª gi·∫£ ƒë·ªÉ r√∫t {coin} c·ªßa {member.name} nh∆∞ng kh√¥ng th√†nh c√¥ng.")
            return
    else:
        await ctx.reply("B·∫°n l√†m ƒë√©o g√¨ c√≥ th·∫ª m√† r√∫t")

@bot.command(name="op", help='`$op <ng∆∞·ªùi ch∆°i>`\n> sƒÉn smart')
async def op(ctx, member: discord.Member):
    if not await check_permission(ctx):
        return

    killer_id = str(ctx.author.id)
    victim_id = str(member.id)
    success = 0.5

    killer = get_user(killer_id)
    victim = get_user(victim_id)

    if killer is None:
        await ctx.reply("C√≥ v·∫ª b·∫°n ch∆∞a ch∆°i l·∫ßn n√†o tr∆∞·ªõc ƒë√¢y vui l√≤ng d√πng $start ƒë·ªÉ t·∫°o t√†i kho·∫£n.")
        return

    if victim is None:
        await ctx.reply("N·∫°n nh√¢n ko c√≥ trong d·ªØ li·ªáu c·ªßa tr√≤ ch∆°i.")
        return

    now = datetime.datetime.now()
    last_rob = killer.get('last_rob')
    cooldown_time = 60 * 60
    if last_rob:
        time_elapsed = (now - datetime.datetime.strptime(last_rob, "%Y-%m-%d %H:%M:%S")).total_seconds()
        if time_elapsed < cooldown_time:
            if killer['items'].get(':fast_forward: Skip', 0) > 0:
                killer['items'][':fast_forward: Skip'] -= 1
                await ctx.reply("B·∫°n ƒë√£ s·ª≠ d·ª•ng :fast_forward: Skip ƒë·ªÉ b·ªè qua th·ªùi gian ch·ªù!")
            else:
                remaining_time = cooldown_time - time_elapsed
                hours, remainder = divmod(remaining_time, 3600)
                minutes, seconds = divmod(remainder, 60)
                await ctx.reply(f"B·∫°n ph·∫£i ch·ªù {int(hours)} gi·ªù {int(minutes)} ph√∫t {int(seconds)} gi√¢y tr∆∞·ªõc khi sƒÉn l·∫°i.")
                return

    if killer['items'].get(':bulb: Th√¥ng minh', 0) <= 0:
        await ctx.reply("B·∫°n l√†m ƒë√©o g√¨ c√≥ s·ª± th√¥ng minh :rofl:")
        return

    if victim_id == killer_id:
        await ctx.reply('m√†y t√≠nh t·ª± solo √† con, m√©o c√≥ ƒë√¢u nh√© :>')
        return

    if killer['items'].get('<:big_nao:1308790909353328640> si√™u th√¥ng minh `Legendary`', 0) > 0:
        success += 0.5

    if random.random() < success:
        killer['items'][':bulb: Th√¥ng minh'] -= 1
        await ctx.reply(f"B·∫°n ƒë√£ s·ª≠ d·ª•ng s·ª± th√¥ng minh ƒë·ªÉ ao tr√¨nh {member.name} v√† ƒë√£ th√†nh c√¥ng!")

        victim_smart = victim.get('smart', 0)
        if victim_smart <= 0:
            await ctx.reply(f"{member.name} kh√¥ng c√≥ h·ªçc v·∫•n ƒë·ªÉ h√∫p!")
            return

        stolen_points = round(victim_smart * 0.1)
        victim['smart'] -= round(stolen_points * 0.5)
        killer['smart'] += stolen_points
        killer['points'] += stolen_points
        killer['last_rob'] = now.strftime("%Y-%m-%d %H:%M:%S")

        update_user(killer_id, killer)
        update_user(victim_id, victim)

        await ctx.reply(f"B·∫°n ƒë√£ h√∫p ƒë∆∞·ª£c {format_currency(stolen_points)} {coin}, h·ªçc v·∫•n t·ª´ {member.name}!")
    else:
        killer['items'][':bulb: Th√¥ng minh'] -= 1
        update_user(killer_id, killer)
        await ctx.reply(f"B·∫°n ƒë√£ s·ª≠ d·ª•ng s·ª± th√¥ng minh ƒë·ªÉ ao tr√¨nh {member.name} nh∆∞ng kh√¥ng th√†nh c√¥ng.")

@bot.command(name="ping", help='`$ping`\n> xem ƒë·ªô tr·ªÖ c·ªßa bot')
async def ping(ctx):
    latency = bot.latency
    await ctx.reply(f'Ping : {latency * 1000:.2f}ms.')

@bot.command(name="lb", help='`$lb`\n> xem b·∫£ng x·∫øp h·∫°ng')
async def lb(ctx, kind: str = "a"):
    if not await check_permission(ctx):
        return

    kind_map = {
        "a": ("points", "üè¶ T√†i kho·∫£n"),
        "o": ("company_balance", "üè¢ C√¥ng ty"),
        "s": ("smart", "üìö H·ªçc v·∫•n"),
    }

    field, label = kind_map.get(kind, (None, None))
    if not field:
        await ctx.reply(
            "Lo·∫°i b·∫£ng x·∫øp h·∫°ng kh√¥ng h·ª£p l·ªá. Vui l√≤ng s·ª≠ d·ª•ng:\n"
            "`$lb a` - T√†i kho·∫£n\n"
            "`$lb o` - C√¥ng ty\n"
            "`$lb s` - H·ªçc v·∫•n."
        )
        return

    top_users = users_col.find().sort(field, -1).limit(10)
    leaderboard = ""
    for idx, user in enumerate(top_users, start=1):
        try:
            member = await bot.fetch_user(int(user['_id']))
            name = member.name
        except:
            name = f"Ng∆∞·ªùi ch∆°i {user['_id']}"

        score = user.get(field, 0)
        leaderboard += f"**{idx}.** {name}: `{format_currency(score)}`\n"

    embed = discord.Embed(
        title=f"B·∫£ng x·∫øp h·∫°ng {label}",
        description=leaderboard or "Kh√¥ng c√≥ d·ªØ li·ªáu.",
        color=discord.Color.gold()
    )
    await ctx.reply(embed=embed)

@bot.command(name='gacha', help='`$gacha`\n> gacha ra nh·ªØng th·ª© hay ho')
async def gacha(ctx):
    if not await check_permission(ctx):
        return

    user_id = str(ctx.author.id)
    user_roles = [role.name for role in ctx.author.roles]

    user = users_col.find_one({"_id": user_id})
    if not user:
        await ctx.reply("B·∫°n ch∆∞a c√≥ t√†i kho·∫£n. D√πng `$start` ƒë·ªÉ b·∫Øt ƒë·∫ßu.")
        return

    # Ki·ªÉm tra cooldown
    now = datetime.datetime.now()
    last_gacha = user.get('last_gacha')
    if last_gacha:
        time_elapsed = (now - datetime.datetime.strptime(last_gacha, "%Y-%m-%d %H:%M:%S")).total_seconds()
        if time_elapsed < 3600:
            minutes, seconds = divmod(int(3600 - time_elapsed), 60)
            await ctx.reply(f"B·∫°n ph·∫£i ch·ªù {minutes} ph√∫t {seconds} gi√¢y tr∆∞·ªõc khi quay gacha l·∫°i.")
            return

    if "Trung h·ªçc Ph·ªï th√¥ng" in user_roles:
        if user.get('points', 0) < 10_000_000_000:
            await ctx.reply(f'B·∫°n kh√¥ng ƒë·ªß {coin} ƒë·ªÉ gacha!')
            return

        # Tr·ª´ ti·ªÅn v√† th√¥ng minh
        users_col.update_one(
            {"_id": user_id},
            {
                "$inc": {
                    "points": -10_000_000_000,
                    "smart": -1_000_000
                },
                "$set": {
                    "last_gacha": now.strftime("%Y-%m-%d %H:%M:%S")
                }
            }
        )

        result = roll_gacha_from_pool()
        item_name = result.get("name", "Kh√¥ng r√µ")
        rarity = result.get("rarity", "kh√¥ng x√°c ƒë·ªãnh")

        # C·∫≠p nh·∫≠t v·∫≠t ph·∫©m
        users_col.update_one(
            {"_id": user_id},
            {"$inc": {f"items.{item_name}": 1}}
        )

        rarity_colors = {
            "t·ªët": discord.Color.green(),
            "hi·∫øm": discord.Color.blue(),
            "s·ª≠ thi": discord.Color.purple(),
            "huy·ªÅn tho·∫°i": discord.Color.orange()
        }

        embed = discord.Embed(
            title="üé≤ Gacha Roll üé≤",
            description=f"B·∫°n ƒë√£ quay ƒë∆∞·ª£c: **{item_name}**\nüîπ ƒê·ªô hi·∫øm: `{rarity.upper()}`",
            color=rarity_colors.get(rarity, discord.Color.gold())
        )
        await ctx.reply(embed=embed)

@bot.command(name='study', help='`$study`\n> H·ªçc tƒÉng tr√¨nh ƒë·ªô')
async def study(ctx):
    if not await check_permission(ctx):
        return

    user_id = str(ctx.author.id)
    now = datetime.datetime.now()

    user = users_col.find_one({"_id": user_id})
    if not user:
        await ctx.reply("B·∫°n ch∆∞a c√≥ t√†i kho·∫£n. D√πng `$start` ƒë·ªÉ b·∫Øt ƒë·∫ßu.")
        return

    last_study = user.get('last_study')
    cooldown_time = 5 * 60  # 5 ph√∫t

    if last_study:
        time_elapsed = (now - datetime.datetime.strptime(last_study, "%Y-%m-%d %H:%M:%S")).total_seconds()
        if time_elapsed < cooldown_time:
            minutes, seconds = divmod(int(cooldown_time - time_elapsed), 60)
            await ctx.reply(f"B·∫°n c·∫ßn ch·ªù {minutes} ph√∫t {seconds} gi√¢y tr∆∞·ªõc khi c√≥ th·ªÉ h·ªçc ti·∫øp!")
            return

    # TƒÉng smart v√† c·∫≠p nh·∫≠t last_study
    users_col.update_one(
        {"_id": user_id},
        {
            "$inc": {"smart": 10},
            "$set": {"last_study": now.strftime("%Y-%m-%d %H:%M:%S")}
        }
    )

    await ctx.reply("B·∫°n v·ª´a h·ªçc xong ra ch∆°i th√¥i!")

@bot.command(name="clear")
async def clear_messages(ctx, amount: int):
    if not ctx.author.guild_permissions.manage_messages:
        await ctx.reply("B·∫°n kh√¥ng c√≥ quy·ªÅn x√≥a tin nh·∫Øn!")
        return

    await ctx.channel.purge(limit=amount)

# ==== RUN ====
keep_alive()
bot.run(DISCORD_TOKEN)
